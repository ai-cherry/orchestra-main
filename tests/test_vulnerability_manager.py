"""
Unit tests for the vulnerability manager.

This module contains unit tests for the vulnerability manager component
of the WIF implementation plan.
"""

import os
import shutil
import tempfile
import unittest
from pathlib import Path
from unittest.mock import patch, MagicMock

from wif_implementation import (
    ImplementationPhase,
    TaskStatus,
    Task,
    ImplementationPlan,
    Vulnerability,
    VulnerabilityManager,
)


class TestVulnerabilityManager(unittest.TestCase):
    """Test cases for the vulnerability manager."""
    
    def setUp(self):
        """Set up the test environment."""
        # Create a temporary directory
        self.temp_dir = tempfile.mkdtemp()
        self.base_path = Path(self.temp_dir)
        
        # Create a test implementation plan
        self.plan = ImplementationPlan()
        self.plan.add_task(Task(
            name="inventory_vulnerabilities",
            description="Create an inventory of all vulnerabilities",
            phase=ImplementationPhase.VULNERABILITIES,
        ))
        self.plan.add_task(Task(
            name="prioritize_vulnerabilities",
            description="Prioritize vulnerabilities based on severity and impact",
            phase=ImplementationPhase.VULNERABILITIES,
            dependencies=["inventory_vulnerabilities"],
        ))
        
        # Create a vulnerability manager
        self.manager = VulnerabilityManager(
            base_path=self.base_path,
            verbose=True,
            dry_run=True,
        )
    
    def tearDown(self):
        """Clean up the test environment."""
        # Remove the temporary directory
        shutil.rmtree(self.temp_dir)
    
    def test_init(self):
        """Test initialization of the vulnerability manager."""
        self.assertEqual(self.manager.base_path, self.base_path)
        self.assertTrue(self.manager.verbose)
        self.assertTrue(self.manager.dry_run)
        self.assertEqual(self.manager.vulnerabilities, [])
    
    def test_inventory_vulnerabilities_sample(self):
        """Test creating a sample inventory of vulnerabilities."""
        # Mock the _check_command method to return False
        with patch.object(self.manager, '_check_command', return_value=False):
            # Execute the task
            result = self.manager._inventory_vulnerabilities(self.plan)
            
            # Check the result
            self.assertTrue(result)
            self.assertEqual(len(self.manager.vulnerabilities), 38)
            
            # Check the vulnerabilities
            high_severity = [v for v in self.manager.vulnerabilities if v.severity == "high"]
            moderate_severity = [v for v in self.manager.vulnerabilities if v.severity == "moderate"]
            
            self.assertEqual(len(high_severity), 16)
            self.assertEqual(len(moderate_severity), 22)
    
    @patch('subprocess.check_output')
    def test_inventory_vulnerabilities_github(self, mock_check_output):
        """Test creating an inventory of vulnerabilities using GitHub CLI."""
        # Mock the _check_command method to return True
        with patch.object(self.manager, '_check_command', return_value=True):
            # Mock subprocess.check_output to return a git config
            mock_check_output.side_effect = [
                "https://github.com/ai-cherry/orchestra-main.git\n",  # git config
                '[{"number": 1, "security_advisory": {"ghsa_id": "GHSA-1234", "severity": "high", "description": "Test vulnerability"}, "security_vulnerability": {"package": {"name": "test-package"}, "vulnerable_version_range": "1.0.0", "first_patched_version": {"identifier": "1.0.1"}}, "dependency": {"scope": "direct"}}]',  # gh api
            ]
            
            # Execute the task
            result = self.manager._inventory_vulnerabilities(self.plan)
            
            # Check the result
            self.assertTrue(result)
            self.assertEqual(len(self.manager.vulnerabilities), 1)
            
            # Check the vulnerability
            vuln = self.manager.vulnerabilities[0]
            self.assertEqual(vuln.id, "GHSA-1234")
            self.assertEqual(vuln.package, "test-package")
            self.assertEqual(vuln.severity, "high")
            self.assertEqual(vuln.description, "Test vulnerability")
            self.assertEqual(vuln.current_version, "1.0.0")
            self.assertEqual(vuln.fixed_version, "1.0.1")
            self.assertTrue(vuln.is_direct)
    
    def test_prioritize_vulnerabilities(self):
        """Test prioritizing vulnerabilities."""
        # Create some test vulnerabilities
        self.manager.vulnerabilities = [
            Vulnerability(
                id="GHSA-1",
                package="package1",
                severity="moderate",
                description="Moderate severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=True,
            ),
            Vulnerability(
                id="GHSA-2",
                package="package2",
                severity="high",
                description="High severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=False,
            ),
            Vulnerability(
                id="GHSA-3",
                package="package3",
                severity="high",
                description="High severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=True,
            ),
            Vulnerability(
                id="GHSA-4",
                package="package4",
                severity="critical",
                description="Critical severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=False,
            ),
        ]
        
        # Execute the task
        result = self.manager._prioritize_vulnerabilities(self.plan)
        
        # Check the result
        self.assertTrue(result)
        
        # Check the prioritization
        self.assertEqual(self.manager.vulnerabilities[0].id, "GHSA-4")  # Critical severity
        self.assertEqual(self.manager.vulnerabilities[1].id, "GHSA-3")  # High severity, direct
        self.assertEqual(self.manager.vulnerabilities[2].id, "GHSA-2")  # High severity, transitive
        self.assertEqual(self.manager.vulnerabilities[3].id, "GHSA-1")  # Moderate severity
    
    def test_update_direct_dependencies(self):
        """Test updating direct dependencies."""
        # Create some test vulnerabilities
        self.manager.vulnerabilities = [
            Vulnerability(
                id="GHSA-1",
                package="lodash",
                severity="high",
                description="High severity vulnerability",
                current_version="4.17.15",
                fixed_version="4.17.21",
                is_direct=True,
            ),
            Vulnerability(
                id="GHSA-2",
                package="axios",
                severity="high",
                description="High severity vulnerability",
                current_version="0.21.0",
                fixed_version="0.21.1",
                is_direct=True,
            ),
            Vulnerability(
                id="GHSA-3",
                package="requests",
                severity="high",
                description="High severity vulnerability",
                current_version="2.25.0",
                fixed_version="2.25.1",
                is_direct=True,
            ),
        ]
        
        # Execute the task
        result = self.manager._update_direct_dependencies(self.plan)
        
        # Check the result
        self.assertTrue(result)
        
        # In dry run mode, vulnerabilities should not be marked as fixed
        for vuln in self.manager.vulnerabilities:
            self.assertFalse(vuln.is_fixed)
        
        # Create a non-dry-run manager
        manager = VulnerabilityManager(
            base_path=self.base_path,
            verbose=True,
            dry_run=False,
        )
        manager.vulnerabilities = self.manager.vulnerabilities.copy()
        
        # Execute the task
        result = manager._update_direct_dependencies(self.plan)
        
        # Check the result
        self.assertTrue(result)
        
        # Vulnerabilities should be marked as fixed
        for vuln in manager.vulnerabilities:
            self.assertTrue(vuln.is_fixed)
            self.assertIsNotNone(vuln.fix_command)
    
    def test_address_transitive_dependencies(self):
        """Test addressing transitive dependencies."""
        # Create some test vulnerabilities
        self.manager.vulnerabilities = [
            Vulnerability(
                id="GHSA-1",
                package="lodash",
                severity="high",
                description="High severity vulnerability",
                current_version="4.17.15",
                fixed_version="4.17.21",
                is_direct=False,
            ),
            Vulnerability(
                id="GHSA-2",
                package="axios",
                severity="high",
                description="High severity vulnerability",
                current_version="0.21.0",
                fixed_version="0.21.1",
                is_direct=False,
            ),
            Vulnerability(
                id="GHSA-3",
                package="requests",
                severity="high",
                description="High severity vulnerability",
                current_version="2.25.0",
                fixed_version="2.25.1",
                is_direct=False,
            ),
        ]
        
        # Execute the task
        result = self.manager._address_transitive_dependencies(self.plan)
        
        # Check the result
        self.assertTrue(result)
        
        # In dry run mode, vulnerabilities should not be marked as fixed
        for vuln in self.manager.vulnerabilities:
            self.assertFalse(vuln.is_fixed)
        
        # Create a non-dry-run manager
        manager = VulnerabilityManager(
            base_path=self.base_path,
            verbose=True,
            dry_run=False,
        )
        manager.vulnerabilities = self.manager.vulnerabilities.copy()
        
        # Execute the task
        result = manager._address_transitive_dependencies(self.plan)
        
        # Check the result
        self.assertTrue(result)
        
        # Vulnerabilities should be marked as fixed
        for vuln in manager.vulnerabilities:
            self.assertTrue(vuln.is_fixed)
            self.assertIsNotNone(vuln.fix_command)
    
    def test_run_security_scans(self):
        """Test running security scans."""
        # Create some test vulnerabilities
        self.manager.vulnerabilities = [
            Vulnerability(
                id="GHSA-1",
                package="lodash",
                severity="high",
                description="High severity vulnerability",
                current_version="4.17.15",
                fixed_version="4.17.21",
                is_direct=True,
                is_fixed=True,
            ),
            Vulnerability(
                id="GHSA-2",
                package="axios",
                severity="high",
                description="High severity vulnerability",
                current_version="0.21.0",
                fixed_version="0.21.1",
                is_direct=True,
                is_fixed=False,
            ),
        ]
        
        # Mock the _check_command method to return True
        with patch.object(self.manager, '_check_command', return_value=True):
            # Execute the task
            result = self.manager._run_security_scans(self.plan)
            
            # Check the result
            self.assertTrue(result)
    
    def test_verify_functionality(self):
        """Test verifying application functionality."""
        # Mock the _check_command method to return True
        with patch.object(self.manager, '_check_command', return_value=True):
            # Execute the task
            result = self.manager._verify_functionality(self.plan)
            
            # Check the result
            self.assertTrue(result)
    
    def test_check_command(self):
        """Test checking if a command is available."""
        # Test with a command that should be available
        with patch('subprocess.check_call', return_value=0):
            self.assertTrue(self.manager._check_command("python"))
        
        # Test with a command that should not be available
        with patch('subprocess.check_call', side_effect=Exception("Command not found")):
            self.assertFalse(self.manager._check_command("nonexistent-command"))
    
    def test_get_vulnerabilities_by_severity(self):
        """Test getting vulnerabilities by severity."""
        # Create some test vulnerabilities
        self.manager.vulnerabilities = [
            Vulnerability(
                id="GHSA-1",
                package="package1",
                severity="moderate",
                description="Moderate severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=True,
            ),
            Vulnerability(
                id="GHSA-2",
                package="package2",
                severity="high",
                description="High severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=False,
            ),
            Vulnerability(
                id="GHSA-3",
                package="package3",
                severity="high",
                description="High severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=True,
            ),
        ]
        
        # Get vulnerabilities by severity
        high_severity = self.manager.get_vulnerabilities_by_severity("high")
        moderate_severity = self.manager.get_vulnerabilities_by_severity("moderate")
        
        # Check the results
        self.assertEqual(len(high_severity), 2)
        self.assertEqual(len(moderate_severity), 1)
        self.assertEqual(high_severity[0].id, "GHSA-2")
        self.assertEqual(high_severity[1].id, "GHSA-3")
        self.assertEqual(moderate_severity[0].id, "GHSA-1")
    
    def test_get_fixed_vulnerabilities(self):
        """Test getting fixed vulnerabilities."""
        # Create some test vulnerabilities
        self.manager.vulnerabilities = [
            Vulnerability(
                id="GHSA-1",
                package="package1",
                severity="moderate",
                description="Moderate severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=True,
                is_fixed=True,
            ),
            Vulnerability(
                id="GHSA-2",
                package="package2",
                severity="high",
                description="High severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=False,
                is_fixed=False,
            ),
            Vulnerability(
                id="GHSA-3",
                package="package3",
                severity="high",
                description="High severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=True,
                is_fixed=True,
            ),
        ]
        
        # Get fixed vulnerabilities
        fixed = self.manager.get_fixed_vulnerabilities()
        
        # Check the results
        self.assertEqual(len(fixed), 2)
        self.assertEqual(fixed[0].id, "GHSA-1")
        self.assertEqual(fixed[1].id, "GHSA-3")
    
    def test_get_unfixed_vulnerabilities(self):
        """Test getting unfixed vulnerabilities."""
        # Create some test vulnerabilities
        self.manager.vulnerabilities = [
            Vulnerability(
                id="GHSA-1",
                package="package1",
                severity="moderate",
                description="Moderate severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=True,
                is_fixed=True,
            ),
            Vulnerability(
                id="GHSA-2",
                package="package2",
                severity="high",
                description="High severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=False,
                is_fixed=False,
            ),
            Vulnerability(
                id="GHSA-3",
                package="package3",
                severity="high",
                description="High severity vulnerability",
                current_version="1.0.0",
                fixed_version="1.0.1",
                is_direct=True,
                is_fixed=True,
            ),
        ]
        
        # Get unfixed vulnerabilities
        unfixed = self.manager.get_unfixed_vulnerabilities()
        
        # Check the results
        self.assertEqual(len(unfixed), 1)
        self.assertEqual(unfixed[0].id, "GHSA-2")


if __name__ == "__main__":
    unittest.main()