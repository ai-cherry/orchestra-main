version: '3.8'

services:
  # PostgreSQL Database with optimizations
  postgres:
    image: postgres:15-alpine
    container_name: cherry_ai_postgres_prod
    restart: unless-stopped
    environment:
      POSTGRES_USER: cherry_ai
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-secure_cherry_password}
      POSTGRES_DB: cherry_ai
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data_prod:/var/lib/postgresql/data
      - ./database/unified_schema.sql:/docker-entrypoint-initdb.d/01-schema.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U cherry_ai -d cherry_ai"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '1'

  # Redis with persistence and optimization
  redis:
    image: redis:7-alpine
    container_name: cherry_ai_redis_prod
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data_prod:/data
    command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'

  # Weaviate Vector Database
  weaviate:
    image: semitechnologies/weaviate:1.24.10
    container_name: cherry_ai_weaviate_prod
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      QUERY_DEFAULTS_LIMIT: 25
      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: 'true'
      PERSISTENCE_DATA_PATH: '/var/lib/weaviate'
      DEFAULT_VECTORIZER_MODULE: 'none'
      CLUSTER_HOSTNAME: 'node1'
      LIMIT_RESOURCES: 'true'
      GOMAXPROCS: '2'
    volumes:
      - weaviate_data_prod:/var/lib/weaviate
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/v1/.well-known/ready"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '2'

  # Cherry AI API Server (Production Optimized)
  api:
    build:
      context: .
      dockerfile: Dockerfile.api
    container_name: cherry_ai_api_prod
    restart: unless-stopped
    environment:
      - DATABASE_URL=postgresql://cherry_ai:${POSTGRES_PASSWORD:-secure_cherry_password}@postgres:5432/cherry_ai
      - REDIS_URL=redis://redis:6379/0
      - WEAVIATE_URL=http://weaviate:8080
      - CHERRY_AI_ENV=production
      - SECRET_KEY=${SECRET_KEY}
      - DOMAIN=cherry-ai.me
      - CORS_ORIGINS=https://cherry-ai.me,https://www.cherry-ai.me
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      weaviate:
        condition: service_healthy
    volumes:
      - ./logs:/app/logs
    command: gunicorn api.main:app -w 4 -k uvicorn.workers.UvicornWorker -b 0.0.0.0:8000 --max-requests 1000 --max-requests-jitter 100
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/system/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '2'

  # AI Coding Bridge (Your Manus AI Connector)
  ai_bridge:
    build:
      context: .
      dockerfile: Dockerfile.bridge
    container_name: cherry_ai_bridge_prod
    restart: unless-stopped
    environment:
      - BRIDGE_HOST=0.0.0.0
      - BRIDGE_PORT=8765
      - REDIS_URL=redis://redis:6379/1
      - SECRET_KEY=${SECRET_KEY}
    ports:
      - "8765:8765"
    depends_on:
      - redis
      - api
    volumes:
      - ./logs:/app/logs
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8765/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '1'

  # Nginx Reverse Proxy with SSL and Domain Support
  nginx:
    image: nginx:alpine
    container_name: cherry_ai_nginx_prod
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/production.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
      - ./admin-interface:/usr/share/nginx/html
      - ./logs/nginx:/var/log/nginx
    depends_on:
      - api
      - ai_bridge
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.5'

  # Health Monitor with Auto-Recovery
  health_monitor:
    build:
      context: .
      dockerfile: Dockerfile.monitor
    container_name: cherry_ai_monitor_prod
    restart: unless-stopped
    environment:
      - MONITOR_INTERVAL=30
      - SLACK_WEBHOOK=${SLACK_WEBHOOK}
      - EMAIL_ALERTS=${EMAIL_ALERTS}
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./logs:/app/logs
    depends_on:
      - api
      - ai_bridge
    deploy:
      resources:
        limits:
          memory: 128M
          cpus: '0.25'

  # Log Aggregator
  fluentd:
    image: fluent/fluentd:v1.16-debian-1
    container_name: cherry_ai_logs_prod
    restart: unless-stopped
    volumes:
      - ./fluentd/fluent.conf:/fluentd/etc/fluent.conf
      - ./logs:/logs
    ports:
      - "24224:24224"
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.25'

volumes:
  postgres_data_prod:
    driver: local
  redis_data_prod:
    driver: local
  weaviate_data_prod:
    driver: local

networks:
  default:
    name: cherry_ai_production
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
