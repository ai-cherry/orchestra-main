# Optimized GitHub Actions workflow for AI Orchestra
# Features:
# - Dependency caching
# - Parallel job execution
# - Performance testing
# - Workload Identity Federation authentication
# - Automated deployment to Cloud Run

name: Optimized Build and Deploy

on:
  push:
    branches: [main]
    paths:
      - 'ai-orchestra/**'
      - '.github/workflows/optimized-build-deploy.yml'
      - 'pyproject.toml'
      - 'poetry.lock'
  pull_request:
    branches: [main]
    paths:
      - 'ai-orchestra/**'
      - '.github/workflows/optimized-build-deploy.yml'
      - 'pyproject.toml'
      - 'poetry.lock'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  REGION: ${{ secrets.GCP_REGION }}
  SERVICE_NAME: ai-orchestra-api
  PYTHON_VERSION: '3.11'

jobs:
  # Lint and format check
  lint:
    name: Lint and Format Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 1.7.1
          virtualenvs-create: true
          virtualenvs-in-project: true
      
      - name: Cache Poetry dependencies
        uses: actions/cache@v3
        with:
          path: .venv
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-
      
      - name: Install dependencies
        run: poetry install --no-interaction --no-root
      
      - name: Run linters
        run: |
          poetry run black --check ai-orchestra
          poetry run isort --check-only ai-orchestra
          poetry run flake8 ai-orchestra
          poetry run mypy ai-orchestra

  # Run tests in parallel
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: lint
    strategy:
      matrix:
        test-group: [unit, integration]
        include:
          - test-group: unit
            path: tests/unit
          - test-group: integration
            path: tests/integration
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 1.7.1
          virtualenvs-create: true
          virtualenvs-in-project: true
      
      - name: Cache Poetry dependencies
        uses: actions/cache@v3
        with:
          path: .venv
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-
      
      - name: Install dependencies
        run: poetry install --no-interaction --no-root
      
      - name: Run ${{ matrix.test-group }} tests
        run: poetry run pytest ${{ matrix.path }} --cov=ai-orchestra --cov-report=xml
      
      - name: Upload coverage report
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: ${{ matrix.test-group }}
          name: ${{ matrix.test-group }}-tests

  # Performance testing
  performance:
    name: Performance Testing
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 1.7.1
          virtualenvs-create: true
          virtualenvs-in-project: true
      
      - name: Cache Poetry dependencies
        uses: actions/cache@v3
        with:
          path: .venv
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-
      
      - name: Install dependencies
        run: poetry install --no-interaction --no-root
      
      - name: Run performance tests
        run: |
          if [ -d "tests/performance" ]; then
            poetry run pytest tests/performance --benchmark-json output.json
          else
            echo "No performance tests found. Skipping."
            echo '{"benchmarks": []}' > output.json
          fi
      
      - name: Store benchmark result
        uses: benchmark-action/github-action-benchmark@v1
        with:
          tool: 'pytest'
          output-file-path: output.json
          github-token: ${{ secrets.GITHUB_TOKEN }}
          auto-push: true
          comment-on-alert: true
          fail-on-alert: false
          alert-threshold: '200%'
          comment-always: true

  # Build and push Docker image
  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [test, performance]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    environment: ${{ github.event.inputs.environment || 'dev' }}
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Google Auth via Workload Identity Federation
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      
      - name: Authorize Docker push
        run: gcloud auth configure-docker gcr.io
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ai-orchestra/Dockerfile
          push: true
          tags: |
            gcr.io/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}:latest
            gcr.io/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}:${{ github.sha }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new
      
      # Temp fix for https://github.com/docker/build-push-action/issues/252
      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  # Deploy to Cloud Run
  deploy:
    name: Deploy to Cloud Run
    runs-on: ubuntu-latest
    needs: build
    environment: ${{ github.event.inputs.environment || 'dev' }}
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Google Auth via Workload Identity Federation
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      
      - name: Deploy to Cloud Run
        id: deploy
        uses: google-github-actions/deploy-cloudrun@v2
        with:
          service: ${{ env.SERVICE_NAME }}
          image: gcr.io/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}:${{ github.sha }}
          region: ${{ env.REGION }}
          flags: |
            --allow-unauthenticated
            --memory=512Mi
            --cpu=1
            --min-instances=0
            --max-instances=10
            --concurrency=80
            --timeout=300s
            --set-env-vars=ENV=${{ github.event.inputs.environment || 'dev' }}
            --cpu-throttling
      
      - name: Show Output
        run: |
          echo "Service deployed successfully!"
          echo "Service URL: ${{ steps.deploy.outputs.url }}"
      
      - name: Verify Deployment
        run: |
          # Wait for the service to be fully deployed
          sleep 30
          
          # Check if the service is responding
          curl -s -o /dev/null -w "%{http_code}" ${{ steps.deploy.outputs.url }}/health | grep 200 || exit 1
          
          echo "Deployment verified successfully!"

  # Monitor deployment
  monitor:
    name: Monitor Deployment
    runs-on: ubuntu-latest
    needs: deploy
    environment: ${{ github.event.inputs.environment || 'dev' }}
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Google Auth via Workload Identity Federation
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      
      - name: Check Cloud Run service metrics
        run: |
          # Get service URL
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} --region ${{ env.REGION }} --format="value(status.url)")
          
          # Check service health
          echo "Checking service health..."
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $SERVICE_URL/health)
          echo "Health endpoint status: $HEALTH_STATUS"
          
          # Get service metrics
          echo "Getting service metrics..."
          gcloud run services describe ${{ env.SERVICE_NAME }} --region ${{ env.REGION }} --format="yaml(status)"
          
          # Check recent logs for errors
          echo "Checking recent logs for errors..."
          gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=${{ env.SERVICE_NAME }} AND severity>=ERROR" --limit=10 --format="table(timestamp,severity,textPayload)"
          
          echo "Deployment monitoring complete!"