#!/usr/bin/env python3
"""
Complete Domain Orchestration Execution Script
Implements the full multi-model approach for domain separation
"""

import asyncio
import sys
from pathlib import Path

# Add the script directory to Python path
sys.path.insert(0, str(Path(__file__).parent))

from domain_infrastructure_orchestrator import DomainInfrastructureOrchestrator

async def main():
    """Execute complete domain orchestration"""
    
    orchestrator = DomainInfrastructureOrchestrator()
    
    # Complete the orchestration setup
    print("ðŸš€ Starting Multi-Model Domain Infrastructure Orchestration")
    print("=" * 60)
    
    # Phase 1: Generate configurations
    print("\nðŸ“‹ Phase 1: Generating Domain Configurations")
    for domain, config in orchestrator.domains.items():
        print(f"\n  Processing {domain} ({config['name']})...")
        
        # Create Weaviate config
        await orchestrator.create_weaviate_cluster_config(domain, config)
        print(f"    âœ… Weaviate cluster config created")
        
        # Create Airbyte config
        await orchestrator.create_airbyte_config(domain, config)
        print(f"    âœ… Airbyte pipeline config created")
        
        # Create API gateway config
        gateway_config = await orchestrator.create_domain_api_gateway(domain, config)
        print(f"    âœ… API gateway config created")
    
    # Phase 2: Create automation scripts
    print("\nðŸ”§ Phase 2: Creating Automation Scripts")
    
    weaviate_script = await orchestrator.create_weaviate_provisioning_script()
    print(f"  âœ… Weaviate provisioning script: {weaviate_script}")
    
    airbyte_script = await orchestrator.create_airbyte_automation_script()
    print(f"  âœ… Airbyte automation script: {airbyte_script}")
    
    # Phase 3: Create infrastructure components
    print("\nðŸ—ï¸ Phase 3: Creating Infrastructure Components")
    
    interfaces = await orchestrator.create_domain_interfaces()
    print(f"  âœ… Domain interfaces: {interfaces}")
    
    pulumi_infra = await orchestrator.create_pulumi_infrastructure()
    print(f"  âœ… Pulumi infrastructure: {pulumi_infra}")
    
    github_workflow = await orchestrator.create_github_actions_workflow()
    print(f"  âœ… GitHub Actions workflow: {github_workflow}")
    
    # Phase 4: Create domain migration script
    print("\nðŸ“¦ Phase 4: Creating Domain Migration Script")
    
    migration_script_content = '''#!/bin/bash
# Domain Migration Script with Dependency Resolution
# Generated by Domain Infrastructure Orchestrator

set -e

echo "ðŸš€ Starting Domain Migration with Dependency Resolution"
echo "=================================================="

# Phase 1: Create domain directories
echo -e "\\nðŸ“ Creating domain directory structure..."
mkdir -p domains/{Personal,PayReady,ParagonRX}/{services,models,api,config,interfaces}
mkdir -p shared/interfaces
mkdir -p shared/utilities

# Phase 2: Create domain interfaces to resolve dependencies
echo -e "\\nðŸ”— Creating domain interfaces..."
cp shared/interfaces/domain_contracts.py domains/Personal/interfaces/
cp shared/interfaces/domain_contracts.py domains/PayReady/interfaces/
cp shared/interfaces/domain_contracts.py domains/ParagonRX/interfaces/

# Phase 3: Refactor cross-domain dependencies
echo -e "\\nðŸ”§ Refactoring cross-domain dependencies..."

# Extract shared agent logic
cat > shared/utilities/agent_base.py << 'EOF'
"""Base agent functionality shared across domains"""
from abc import ABC, abstractmethod

class BaseAgent(ABC):
    @abstractmethod
    async def process(self, input_data):
        pass
EOF

# Phase 4: Move domain-specific files
echo -e "\\nðŸ“¦ Moving domain-specific files..."

# Personal domain files
echo "  Moving Personal domain files..."
# Move only if files exist
[ -f "agent/app/services/specialized_agents.py" ] && mv agent/app/services/specialized_agents.py domains/Personal/services/
[ -f "ai_components/orchestration/ai_orchestrator.py" ] && mv ai_components/orchestration/ai_orchestrator.py domains/Personal/services/
[ -f "core/orchestrator/src/services/conversation_service.py" ] && mv core/orchestrator/src/services/conversation_service.py domains/Personal/services/

# PayReady domain files
echo "  Moving PayReady domain files..."
[ -d "services/pay_ready" ] && mv services/pay_ready/* domains/PayReady/services/ 2>/dev/null || true
[ -f "workflows/pay_ready_etl_flow.py" ] && mv workflows/pay_ready_etl_flow.py domains/PayReady/services/

# ParagonRX domain files
echo "  Moving ParagonRX domain files..."
[ -f "core/health_monitor.py" ] && mv core/health_monitor.py domains/ParagonRX/services/
[ -f "agent/app/services/system_health.py" ] && mv agent/app/services/system_health.py domains/ParagonRX/services/

# Phase 5: Update imports
echo -e "\\nðŸ”„ Updating import statements..."

# Create import updater script
cat > /tmp/update_imports.py << 'EOF'
import os
import re
from pathlib import Path

def update_imports(file_path):
    """Update imports to use new domain structure"""
    
    with open(file_path, 'r') as f:
        content = f.read()
    
    # Update import patterns
    replacements = [
        (r'from services\.pay_ready', 'from domains.PayReady.services'),
        (r'from agent\.app\.services', 'from domains.Personal.services'),
        (r'from core\.health_monitor', 'from domains.ParagonRX.services.health_monitor'),
        (r'import services\.pay_ready', 'import domains.PayReady.services'),
    ]
    
    for pattern, replacement in replacements:
        content = re.sub(pattern, replacement, content)
    
    with open(file_path, 'w') as f:
        f.write(content)

# Update all Python files
for root, dirs, files in os.walk('domains'):
    for file in files:
        if file.endswith('.py'):
            file_path = Path(root) / file
            update_imports(file_path)
            print(f"Updated imports in: {file_path}")
EOF

python3 /tmp/update_imports.py

# Phase 6: Create domain-specific configurations
echo -e "\\nâš™ï¸ Creating domain-specific configurations..."

# Personal domain config
cat > domains/Personal/config/domain_config.yaml << EOF
domain: Personal
persona: Cherry
database:
  schema: personal_domain
weaviate:
  cluster: personal-cherry-cluster
  collections:
    - personal_memories
    - personal_knowledge
api:
  base_path: /api/personal
  rate_limit: 100
EOF

# PayReady domain config
cat > domains/PayReady/config/domain_config.yaml << EOF
domain: PayReady
persona: Sophia
database:
  schema: payready_domain
weaviate:
  cluster: payready-sophia-cluster
  collections:
    - payready_memories
    - payready_knowledge
api:
  base_path: /api/payready
  rate_limit: 50
EOF

# ParagonRX domain config
cat > domains/ParagonRX/config/domain_config.yaml << EOF
domain: ParagonRX
persona: Karen
database:
  schema: paragonrx_domain
weaviate:
  cluster: paragonrx-karen-cluster
  collections:
    - paragonrx_memories
    - paragonrx_knowledge
api:
  base_path: /api/paragonrx
  rate_limit: 200
EOF

# Phase 7: Validate migration
echo -e "\\nâœ… Validating migration..."

# Check domain directories
for domain in Personal PayReady ParagonRX; do
    if [ -d "domains/$domain" ]; then
        echo "  âœ… $domain domain directory created"
        file_count=$(find domains/$domain -name "*.py" | wc -l)
        echo "     Files: $file_count Python files"
    else
        echo "  âŒ $domain domain directory missing"
    fi
done

echo -e "\\nðŸŽ‰ Domain migration complete!"
echo "Next steps:"
echo "  1. Run: python3 scripts/domain_setup/provision_weaviate_clusters.py"
echo "  2. Run: python3 scripts/domain_setup/configure_airbyte_pipelines.py"
echo "  3. Deploy with: pulumi up -C infrastructure"
'''
    
    migration_script_path = Path("scripts/migrate_domains_with_resolution.sh")
    with open(migration_script_path, 'w') as f:
        f.write(migration_script_content)
    
    import os
    os.chmod(migration_script_path, 0o755)
    print(f"  âœ… Domain migration script: {migration_script_path}")
    
    # Phase 5: Create validation script
    print("\nðŸ” Phase 5: Creating Validation Script")
    
    validation_script_content = '''#!/usr/bin/env python3
"""
Domain Infrastructure Validation Script
Validates the complete domain separation setup
"""

import json
import os
from pathlib import Path

def validate_domain_setup():
    """Validate domain infrastructure setup"""
    
    print("ðŸ” Validating Domain Infrastructure Setup")
    print("=" * 50)
    
    issues = []
    
    # Check domain directories
    print("\\nðŸ“ Checking domain directories...")
    for domain in ["Personal", "PayReady", "ParagonRX"]:
        domain_path = Path(f"domains/{domain}")
        if domain_path.exists():
            print(f"  âœ… {domain} domain directory exists")
            
            # Check subdirectories
            for subdir in ["services", "models", "api", "config", "interfaces"]:
                if (domain_path / subdir).exists():
                    print(f"     âœ… {subdir}/ exists")
                else:
                    print(f"     âŒ {subdir}/ missing")
                    issues.append(f"{domain}/{subdir} directory missing")
        else:
            print(f"  âŒ {domain} domain directory missing")
            issues.append(f"{domain} domain directory missing")
    
    # Check configuration files
    print("\\nâš™ï¸ Checking configuration files...")
    config_files = [
        "config/domains/personal_weaviate.json",
        "config/domains/payready_weaviate.json",
        "config/domains/paragonrx_weaviate.json",
        "config/domains/personal_airbyte.json",
        "config/domains/payready_airbyte.json",
        "config/domains/paragonrx_airbyte.json"
    ]
    
    for config_file in config_files:
        if Path(config_file).exists():
            print(f"  âœ… {config_file}")
            
            # Validate JSON
            try:
                with open(config_file) as f:
                    json.load(f)
                print(f"     âœ… Valid JSON")
            except json.JSONDecodeError as e:
                print(f"     âŒ Invalid JSON: {e}")
                issues.append(f"{config_file} has invalid JSON")
        else:
            print(f"  âŒ {config_file} missing")
            issues.append(f"{config_file} missing")
    
    # Check automation scripts
    print("\\nðŸ”§ Checking automation scripts...")
    scripts = [
        "scripts/domain_setup/provision_weaviate_clusters.py",
        "scripts/domain_setup/configure_airbyte_pipelines.py",
        "scripts/migrate_domains_with_resolution.sh"
    ]
    
    for script in scripts:
        if Path(script).exists():
            print(f"  âœ… {script}")
            
            # Check if executable
            if os.access(script, os.X_OK):
                print(f"     âœ… Executable")
            else:
                print(f"     âŒ Not executable")
                issues.append(f"{script} not executable")
        else:
            print(f"  âŒ {script} missing")
            issues.append(f"{script} missing")
    
    # Check infrastructure files
    print("\\nðŸ—ï¸ Checking infrastructure files...")
    infra_files = [
        "infrastructure/domain_separation.py",
        ".github/workflows/domain_infrastructure.yml",
        "shared/interfaces/domain_contracts.py"
    ]
    
    for infra_file in infra_files:
        if Path(infra_file).exists():
            print(f"  âœ… {infra_file}")
        else:
            print(f"  âŒ {infra_file} missing")
            issues.append(f"{infra_file} missing")
    
    # Summary
    print("\\n" + "=" * 50)
    if issues:
        print(f"âŒ Found {len(issues)} issues:")
        for issue in issues:
            print(f"  - {issue}")
        return False
    else:
        print("âœ… All validations passed!")
        print("\\nðŸŽ‰ Domain infrastructure is ready for deployment!")
        print("\\nNext steps:")
        print("  1. Set environment variables:")
        print("     export WCS_API_KEY=your_weaviate_key")
        print("     export AIRBYTE_URL=your_airbyte_url")
        print("  2. Run migration: bash scripts/migrate_domains_with_resolution.sh")
        print("  3. Provision Weaviate: python3 scripts/domain_setup/provision_weaviate_clusters.py")
        print("  4. Configure Airbyte: python3 scripts/domain_setup/configure_airbyte_pipelines.py")
        print("  5. Deploy infrastructure: pulumi up -C infrastructure")
        return True

if __name__ == "__main__":
    validate_domain_setup()
'''
    
    validation_script_path = Path("scripts/validate_domain_infrastructure.py")
    with open(validation_script_path, 'w') as f:
        f.write(validation_script_content)
    
    os.chmod(validation_script_path, 0o755)
    print(f"  âœ… Validation script: {validation_script_path}")
    
    # Final summary
    print("\n" + "=" * 60)
    print("âœ… MULTI-MODEL DOMAIN ORCHESTRATION COMPLETE!")
    print("=" * 60)
    
    print("\nðŸ“‹ Created Components:")
    print("  â€¢ Domain configurations (Weaviate, Airbyte, API Gateway)")
    print("  â€¢ Automation scripts (provisioning, configuration)")
    print("  â€¢ Domain interfaces (clean contracts)")
    print("  â€¢ Infrastructure code (Pulumi, GitHub Actions)")
    print("  â€¢ Migration script (with dependency resolution)")
    print("  â€¢ Validation script")
    
    print("\nðŸš€ Ready for Execution:")
    print("  1. Review configurations in config/domains/")
    print("  2. Run validation: python3 scripts/validate_domain_infrastructure.py")
    print("  3. Execute migration: bash scripts/migrate_domains_with_resolution.sh")
    print("  4. Deploy infrastructure via GitHub Actions or manually")
    
    print("\nðŸ’¡ The AI coders in Cursor can now:")
    print("  â€¢ Automatically provision Weaviate clusters")
    print("  â€¢ Configure Airbyte pipelines via API")
    print("  â€¢ Deploy domain-separated infrastructure")
    print("  â€¢ Maintain clean domain boundaries")

if __name__ == "__main__":
    asyncio.run(main())