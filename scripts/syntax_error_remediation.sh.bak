#!/bin/bash

# 🔍 Orchestra AI - Comprehensive Syntax Error Search and Remediation
# Safe, systematic approach to finding and fixing syntax errors across the codebase

set -euo pipefail

# Colors
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly YELLOW='\033[1;33m'
readonly RED='\033[0;31m'
readonly CYAN='\033[0;36m'
readonly MAGENTA='\033[0;95m'
readonly NC='\033[0m'

# Configuration
readonly PROJECT_DIR="/Users/lynnmusil/orchestra-dev"
readonly BACKUP_DIR="syntax_backup_$(date +%Y%m%d_%H%M%S)"
readonly REPORT_FILE="syntax_error_report_$(date +%Y%m%d_%H%M%S).md"
readonly LOG_FILE="syntax_remediation.log"

# Logging functions
log_info() { echo -e "${BLUE}$1${NC}" | tee -a "$LOG_FILE"; }
log_success() { echo -e "${GREEN}✅ $1${NC}" | tee -a "$LOG_FILE"; }
log_warning() { echo -e "${YELLOW}⚠️ $1${NC}" | tee -a "$LOG_FILE"; }
log_error() { echo -e "${RED}❌ $1${NC}" | tee -a "$LOG_FILE"; }
log_header() { echo -e "${MAGENTA}$1${NC}" | tee -a "$LOG_FILE"; }

# Counters
declare -i TOTAL_FILES=0
declare -i PYTHON_ERRORS=0
declare -i SHELL_ERRORS=0
declare -i JSON_ERRORS=0
declare -i YAML_ERRORS=0
declare -i JS_TS_ERRORS=0
declare -i FIXED_FILES=0

# Arrays to store results
declare -a PYTHON_ERROR_FILES=()
declare -a SHELL_ERROR_FILES=()
declare -a JSON_ERROR_FILES=()
declare -a YAML_ERROR_FILES=()
declare -a JS_TS_ERROR_FILES=()

# Create backup
create_backup() {
    log_header "📦 Creating Safety Backup"
    
    mkdir -p "$BACKUP_DIR"
    
    # Backup only source files, not generated/cache files
    find . -type f \( \
        -name "*.py" -o \
        -name "*.sh" -o \
        -name "*.json" -o \
        -name "*.yaml" -o \
        -name "*.yml" -o \
        -name "*.js" -o \
        -name "*.ts" -o \
        -name "*.tsx" -o \
        -name "*.jsx" \
    \) \
        -not -path "./.git/*" \
        -not -path "./node_modules/*" \
        -not -path "./venv/*" \
        -not -path "./__pycache__/*" \
        -not -path "./syntax_backup_*/*" \
        -not -path "./security_backup_*/*" \
        -exec cp --parents {} "$BACKUP_DIR/" \; 2>/dev/null || true
    
    log_success "Backup created: $BACKUP_DIR"
}

# Check Python syntax
check_python_syntax() {
    log_header "🐍 Checking Python Syntax"
    
    local python_files
    python_files=$(find . -name "*.py" \
        -not -path "./.git/*" \
        -not -path "./node_modules/*" \
        -not -path "./venv/*" \
        -not -path "./__pycache__/*" \
        -not -path "./syntax_backup_*/*" \
        -not -path "./security_backup_*/*" \
        2>/dev/null || true)
    
    if [ -z "$python_files" ]; then
        log_info "No Python files found"
        return 0
    fi
    
    while IFS= read -r file; do
        [ -z "$file" ] && continue
        ((TOTAL_FILES++))
        
        log_info "Checking: $file"
        
        # Check syntax with python -m py_compile
        if ! python3 -m py_compile "$file" 2>/dev/null; then
            log_error "Syntax error in: $file"
            PYTHON_ERROR_FILES+=("$file")
            ((PYTHON_ERRORS++))
            
            # Get detailed error
            python3 -m py_compile "$file" 2>&1 | head -5 >> "$LOG_FILE"
        fi
        
        # Check with flake8 if available
        if command -v flake8 >/dev/null 2>&1; then
            if ! flake8 --select=E9,F63,F7,F82 "$file" 2>/dev/null; then
                if [[ ! " ${PYTHON_ERROR_FILES[@]} " =~ " ${file} " ]]; then
                    log_warning "Flake8 issues in: $file"
                    PYTHON_ERROR_FILES+=("$file")
                    ((PYTHON_ERRORS++))
                fi
            fi
        fi
        
    done <<< "$python_files"
    
    log_info "Python files checked: $TOTAL_FILES, Errors: $PYTHON_ERRORS"
}

# Check shell script syntax
check_shell_syntax() {
    log_header "🐚 Checking Shell Script Syntax"
    
    local shell_files
    shell_files=$(find . -name "*.sh" \
        -not -path "./.git/*" \
        -not -path "./node_modules/*" \
        -not -path "./venv/*" \
        -not -path "./syntax_backup_*/*" \
        -not -path "./security_backup_*/*" \
        2>/dev/null || true)
    
    if [ -z "$shell_files" ]; then
        log_info "No shell script files found"
        return 0
    fi
    
    while IFS= read -r file; do
        [ -z "$file" ] && continue
        ((TOTAL_FILES++))
        
        log_info "Checking: $file"
        
        # Check syntax with bash -n
        if ! bash -n "$file" 2>/dev/null; then
            log_error "Syntax error in: $file"
            SHELL_ERROR_FILES+=("$file")
            ((SHELL_ERRORS++))
            
            # Get detailed error
            bash -n "$file" 2>&1 | head -3 >> "$LOG_FILE"
        fi
        
        # Check with shellcheck if available
        if command -v shellcheck >/dev/null 2>&1; then
            if ! shellcheck -e SC1091,SC2034,SC2086 "$file" 2>/dev/null; then
                if [[ ! " ${SHELL_ERROR_FILES[@]} " =~ " ${file} " ]]; then
                    log_warning "ShellCheck issues in: $file"
                    # Don't add to error files for shellcheck warnings
                fi
            fi
        fi
        
    done <<< "$shell_files"
    
    log_info "Shell files checked, Errors: $SHELL_ERRORS"
}

# Check JSON syntax
check_json_syntax() {
    log_header "📄 Checking JSON Syntax"
    
    local json_files
    json_files=$(find . -name "*.json" \
        -not -path "./.git/*" \
        -not -path "./node_modules/*" \
        -not -path "./venv/*" \
        -not -path "./syntax_backup_*/*" \
        -not -path "./security_backup_*/*" \
        2>/dev/null || true)
    
    if [ -z "$json_files" ]; then
        log_info "No JSON files found"
        return 0
    fi
    
    while IFS= read -r file; do
        [ -z "$file" ] && continue
        ((TOTAL_FILES++))
        
        log_info "Checking: $file"
        
        # Check syntax with python json module
        if ! python3 -m json.tool "$file" >/dev/null 2>&1; then
            log_error "JSON syntax error in: $file"
            JSON_ERROR_FILES+=("$file")
            ((JSON_ERRORS++))
            
            # Get detailed error
            python3 -m json.tool "$file" 2>&1 | head -3 >> "$LOG_FILE"
        fi
        
    done <<< "$json_files"
    
    log_info "JSON files checked, Errors: $JSON_ERRORS"
}

# Check YAML syntax
check_yaml_syntax() {
    log_header "📋 Checking YAML Syntax"
    
    local yaml_files
    yaml_files=$(find . \( -name "*.yaml" -o -name "*.yml" \) \
        -not -path "./.git/*" \
        -not -path "./node_modules/*" \
        -not -path "./venv/*" \
        -not -path "./syntax_backup_*/*" \
        -not -path "./security_backup_*/*" \
        2>/dev/null || true)
    
    if [ -z "$yaml_files" ]; then
        log_info "No YAML files found"
        return 0
    fi
    
    while IFS= read -r file; do
        [ -z "$file" ] && continue
        ((TOTAL_FILES++))
        
        log_info "Checking: $file"
        
        # Check syntax with python yaml module
        if command -v python3 >/dev/null 2>&1; then
            if ! python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
                log_error "YAML syntax error in: $file"
                YAML_ERROR_FILES+=("$file")
                ((YAML_ERRORS++))
                
                # Get detailed error
                python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>&1 | head -3 >> "$LOG_FILE"
            fi
        fi
        
    done <<< "$yaml_files"
    
    log_info "YAML files checked, Errors: $YAML_ERRORS"
}

# Check JavaScript/TypeScript syntax
check_js_ts_syntax() {
    log_header "🟨 Checking JavaScript/TypeScript Syntax"
    
    local js_ts_files
    js_ts_files=$(find . \( -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" \) \
        -not -path "./.git/*" \
        -not -path "./node_modules/*" \
        -not -path "./venv/*" \
        -not -path "./syntax_backup_*/*" \
        -not -path "./security_backup_*/*" \
        2>/dev/null || true)
    
    if [ -z "$js_ts_files" ]; then
        log_info "No JavaScript/TypeScript files found"
        return 0
    fi
    
    while IFS= read -r file; do
        [ -z "$file" ] && continue
        ((TOTAL_FILES++))
        
        log_info "Checking: $file"
        
        # Check syntax with node if available
        if command -v node >/dev/null 2>&1; then
            if [[ "$file" == *.js ]]; then
                if ! node -c "$file" 2>/dev/null; then
                    log_error "JavaScript syntax error in: $file"
                    JS_TS_ERROR_FILES+=("$file")
                    ((JS_TS_ERRORS++))
                    
                    # Get detailed error
                    node -c "$file" 2>&1 | head -3 >> "$LOG_FILE"
                fi
            fi
        fi
        
        # Check TypeScript with tsc if available
        if command -v tsc >/dev/null 2>&1; then
            if [[ "$file" == *.ts || "$file" == *.tsx ]]; then
                if ! tsc --noEmit --skipLibCheck "$file" 2>/dev/null; then
                    if [[ ! " ${JS_TS_ERROR_FILES[@]} " =~ " ${file} " ]]; then
                        log_warning "TypeScript issues in: $file"
                        # Don't add to error files for TypeScript warnings
                    fi
                fi
            fi
        fi
        
    done <<< "$js_ts_files"
    
    log_info "JavaScript/TypeScript files checked, Errors: $JS_TS_ERRORS"
}

# Fix common Python syntax errors
fix_python_errors() {
    log_header "🔧 Attempting to Fix Python Syntax Errors"
    
    for file in "${PYTHON_ERROR_FILES[@]}"; do
        log_info "Attempting to fix: $file"
        
        local temp_file=$(mktemp)
        cp "$file" "$temp_file"
        
        # Common fixes
        # Fix missing imports
        if grep -q "NameError.*not defined" <<< "$(python3 -m py_compile "$file" 2>&1)"; then
            log_info "Adding common imports to: $file"
            {
                echo "import os"
                echo "import sys"
                echo "from typing import Optional, Dict, List, Any"
                echo ""
                cat "$file"
            } > "$temp_file"
        fi
        
        # Fix indentation issues (basic)
        if grep -q "IndentationError\|TabError" <<< "$(python3 -m py_compile "$file" 2>&1)"; then
            log_info "Fixing indentation in: $file"
            python3 -c "
import re
with open('$temp_file', 'r') as f:
    content = f.read()
# Convert tabs to spaces
content = content.expandtabs(4)
with open('$temp_file', 'w') as f:
    f.write(content)
" 2>/dev/null || true
        fi
        
        # Test if fix worked
        if python3 -m py_compile "$temp_file" 2>/dev/null; then
            mv "$temp_file" "$file"
            log_success "Fixed: $file"
            ((FIXED_FILES++))
        else
            rm -f "$temp_file"
            log_warning "Could not auto-fix: $file"
        fi
    done
}

# Fix common shell script errors
fix_shell_errors() {
    log_header "🔧 Attempting to Fix Shell Script Errors"
    
    for file in "${SHELL_ERROR_FILES[@]}"; do
        log_info "Attempting to fix: $file"
        
        local temp_file=$(mktemp)
        cp "$file" "$temp_file"
        
        # Fix missing shebang
        if ! head -1 "$file" | grep -q "^#!"; then
            log_info "Adding shebang to: $file"
            {
                echo "#!/bin/bash"
                cat "$file"
            } > "$temp_file"
        fi
        
        # Fix common quoting issues (basic)
        sed -i.bak 's/\$(\([^)]*\))/\${\1}/g' "$temp_file" 2>/dev/null || true
        rm -f "$temp_file.bak"
        
        # Test if fix worked
        if bash -n "$temp_file" 2>/dev/null; then
            mv "$temp_file" "$file"
            log_success "Fixed: $file"
            ((FIXED_FILES++))
        else
            rm -f "$temp_file"
            log_warning "Could not auto-fix: $file"
        fi
    done
}

# Fix JSON errors
fix_json_errors() {
    log_header "🔧 Attempting to Fix JSON Syntax Errors"
    
    for file in "${JSON_ERROR_FILES[@]}"; do
        log_info "Attempting to fix: $file"
        
        local temp_file=$(mktemp)
        cp "$file" "$temp_file"
        
        # Try to fix common JSON issues
        python3 -c "
import json
import re

try:
    with open('$temp_file', 'r') as f:
        content = f.read()
    
    # Fix trailing commas
    content = re.sub(r',(\s*[}\]])', r'\1', content)
    
    # Try to parse and reformat
    data = json.loads(content)
    with open('$temp_file', 'w') as f:
        json.dump(data, f, indent=2)
    
    print('Fixed JSON formatting')
except Exception as e:
    print(f'Could not fix: {e}')
" 2>/dev/null
        
        # Test if fix worked
        if python3 -m json.tool "$temp_file" >/dev/null 2>&1; then
            mv "$temp_file" "$file"
            log_success "Fixed: $file"
            ((FIXED_FILES++))
        else
            rm -f "$temp_file"
            log_warning "Could not auto-fix: $file"
        fi
    done
}

# Generate comprehensive report
generate_report() {
    log_header "📊 Generating Comprehensive Report"
    
    cat > "$REPORT_FILE" << EOF
# 🔍 Orchestra AI - Syntax Error Remediation Report
**Generated:** $(date)
**Project:** $PROJECT_DIR

## Summary

| File Type | Files Checked | Errors Found | Auto-Fixed |
|-----------|---------------|--------------|------------|
| Python    | $(find . -name "*.py" -not -path "./.git/*" -not -path "./node_modules/*" -not -path "./venv/*" -not -path "./__pycache__/*" -not -path "./syntax_backup_*/*" | wc -l) | $PYTHON_ERRORS | $(( FIXED_FILES > 0 ? FIXED_FILES : 0 )) |
| Shell     | $(find . -name "*.sh" -not -path "./.git/*" -not -path "./node_modules/*" -not -path "./venv/*" -not -path "./syntax_backup_*/*" | wc -l) | $SHELL_ERRORS | - |
| JSON      | $(find . -name "*.json" -not -path "./.git/*" -not -path "./node_modules/*" -not -path "./venv/*" -not -path "./syntax_backup_*/*" | wc -l) | $JSON_ERRORS | - |
| YAML      | $(find . \( -name "*.yaml" -o -name "*.yml" \) -not -path "./.git/*" -not -path "./node_modules/*" -not -path "./venv/*" -not -path "./syntax_backup_*/*" | wc -l) | $YAML_ERRORS | - |
| JS/TS     | $(find . \( -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" \) -not -path "./.git/*" -not -path "./node_modules/*" -not -path "./venv/*" -not -path "./syntax_backup_*/*" | wc -l) | $JS_TS_ERRORS | - |

**Total Files Checked:** $TOTAL_FILES
**Total Errors Found:** $((PYTHON_ERRORS + SHELL_ERRORS + JSON_ERRORS + YAML_ERRORS + JS_TS_ERRORS))
**Total Files Fixed:** $FIXED_FILES

## Detailed Results

### Python Syntax Errors
EOF

    if [ ${#PYTHON_ERROR_FILES[@]} -gt 0 ]; then
        for file in "${PYTHON_ERROR_FILES[@]}"; do
            echo "- \`$file\`" >> "$REPORT_FILE"
        done
    else
        echo "✅ No Python syntax errors found" >> "$REPORT_FILE"
    fi

    cat >> "$REPORT_FILE" << EOF

### Shell Script Syntax Errors
EOF

    if [ ${#SHELL_ERROR_FILES[@]} -gt 0 ]; then
        for file in "${SHELL_ERROR_FILES[@]}"; do
            echo "- \`$file\`" >> "$REPORT_FILE"
        done
    else
        echo "✅ No shell script syntax errors found" >> "$REPORT_FILE"
    fi

    cat >> "$REPORT_FILE" << EOF

### JSON Syntax Errors
EOF

    if [ ${#JSON_ERROR_FILES[@]} -gt 0 ]; then
        for file in "${JSON_ERROR_FILES[@]}"; do
            echo "- \`$file\`" >> "$REPORT_FILE"
        done
    else
        echo "✅ No JSON syntax errors found" >> "$REPORT_FILE"
    fi

    cat >> "$REPORT_FILE" << EOF

### YAML Syntax Errors
EOF

    if [ ${#YAML_ERROR_FILES[@]} -gt 0 ]; then
        for file in "${YAML_ERROR_FILES[@]}"; do
            echo "- \`$file\`" >> "$REPORT_FILE"
        done
    else
        echo "✅ No YAML syntax errors found" >> "$REPORT_FILE"
    fi

    cat >> "$REPORT_FILE" << EOF

### JavaScript/TypeScript Syntax Errors
EOF

    if [ ${#JS_TS_ERROR_FILES[@]} -gt 0 ]; then
        for file in "${JS_TS_ERROR_FILES[@]}"; do
            echo "- \`$file\`" >> "$REPORT_FILE"
        done
    else
        echo "✅ No JavaScript/TypeScript syntax errors found" >> "$REPORT_FILE"
    fi

    cat >> "$REPORT_FILE" << EOF

## Recommendations

### Manual Review Required
EOF

    local total_errors=$((PYTHON_ERRORS + SHELL_ERRORS + JSON_ERRORS + YAML_ERRORS + JS_TS_ERRORS))
    if [ $total_errors -gt 0 ]; then
        cat >> "$REPORT_FILE" << EOF
The following files require manual review and fixing:

$(for file in "${PYTHON_ERROR_FILES[@]}" "${SHELL_ERROR_FILES[@]}" "${JSON_ERROR_FILES[@]}" "${YAML_ERROR_FILES[@]}" "${JS_TS_ERROR_FILES[@]}"; do
    echo "- \`$file\`"
done | sort -u)

### Next Steps
1. Review each file with syntax errors
2. Use appropriate IDE/editor with syntax highlighting
3. Test fixes in isolated environment
4. Run syntax checks again after fixes
5. Consider adding pre-commit hooks for syntax validation
EOF
    else
        echo "🎉 **All syntax checks passed!** No manual review required." >> "$REPORT_FILE"
    fi

    cat >> "$REPORT_FILE" << EOF

## Tools Used
- **Python:** \`python3 -m py_compile\`, \`flake8\` (if available)
- **Shell:** \`bash -n\`, \`shellcheck\` (if available)
- **JSON:** \`python3 -m json.tool\`
- **YAML:** \`python3 -c "import yaml"\`
- **JavaScript:** \`node -c\` (if available)
- **TypeScript:** \`tsc --noEmit\` (if available)

## Backup Location
Original files backed up to: \`$BACKUP_DIR\`

---
*Generated by Orchestra AI Syntax Error Remediation Tool*
EOF

    log_success "Report generated: $REPORT_FILE"
}

# Main execution
main() {
    echo "🔍 Orchestra AI - Comprehensive Syntax Error Search and Remediation"
    echo "=================================================================="
    echo
    
    log_info "Starting comprehensive syntax error analysis..."
    log_info "Project directory: $PROJECT_DIR"
    log_info "Log file: $LOG_FILE"
    echo
    
    # Initialize log
    echo "Syntax Error Remediation Log - $(date)" > "$LOG_FILE"
    echo "=======================================" >> "$LOG_FILE"
    
    # Create safety backup
    create_backup
    
    # Run syntax checks
    check_python_syntax
    check_shell_syntax
    check_json_syntax
    check_yaml_syntax
    check_js_ts_syntax
    
    # Attempt automatic fixes
    if [ $PYTHON_ERRORS -gt 0 ]; then
        fix_python_errors
    fi
    
    if [ $SHELL_ERRORS -gt 0 ]; then
        fix_shell_errors
    fi
    
    if [ $JSON_ERRORS -gt 0 ]; then
        fix_json_errors
    fi
    
    # Generate comprehensive report
    generate_report
    
    # Final summary
    echo
    log_header "🎉 Syntax Error Remediation Complete!"
    echo
    log_info "📊 Summary:"
    log_info "  Total files checked: $TOTAL_FILES"
    log_info "  Total errors found: $((PYTHON_ERRORS + SHELL_ERRORS + JSON_ERRORS + YAML_ERRORS + JS_TS_ERRORS))"
    log_info "  Files auto-fixed: $FIXED_FILES"
    echo
    log_info "📄 Detailed report: $REPORT_FILE"
    log_info "📦 Backup location: $BACKUP_DIR"
    log_info "📋 Full log: $LOG_FILE"
    echo
    
    if [ $((PYTHON_ERRORS + SHELL_ERRORS + JSON_ERRORS + YAML_ERRORS + JS_TS_ERRORS - FIXED_FILES)) -gt 0 ]; then
        log_warning "Some files still require manual review"
        log_info "💡 Check the report for detailed recommendations"
    else
        log_success "🎉 All syntax issues resolved!"
    fi
}

# Run main function
main "$@" 