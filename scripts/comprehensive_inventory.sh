#!/bin/bash\n# comprehensive_inventory.sh - Smart file discovery and analysis for Project Symphony\n\nset -euo pipefail # Exit on error, undefined variable, or pipe failure\n\nINVENTORY_FILE=\"cleanup_inventory.json\"\nPROJECT_ROOT=\"${1:-.}\" # Allow specifying project root, default to current dir\n\necho \"üîç Starting comprehensive codebase inventory in '$PROJECT_ROOT'...\"\n\n# Ensure project root is an absolute path\nPROJECT_ROOT_ABS=\"$(cd \"$PROJECT_ROOT\" && pwd)\"\n\n# Function to analyze file purpose and lifecycle\nanalyze_file() {\n    local file_rel_path=\"$1\" # Relative path from where find starts\n    local base_dir=\"$2\"      # Base directory find was run from\n    local file_abs_path=\"$base_dir/$file_rel_path\"\n\n    # Normalize path by removing leading ./\n    file_abs_path=\"${file_abs_path/.\//}\"\n    \n    local file_type=\"\"\n    local purpose_heuristic=\"unknown\"\n    local expiration_info=\"none\"\n    local references_count=0\n    local git_tracked_status=\"false\"\n    local owner_info=\"unknown\" # Owner info collection disabled for now due to performance\n\n    # Determine file type (basic)\n    if [[ -x \"$file_abs_path\" ]]; then\n        file_type=\"executable_generic\"\n        if [[ \"$file_abs_path\" == *.sh ]]; then file_type=\"shell_script\"; \n        elif [[ \"$file_abs_path\" == *.py ]]; then file_type=\"python_script\"; fi\n    elif [[ \"$file_abs_path\" == *.py ]]; then file_type=\"python_module\";\n    elif [[ \"$file_abs_path\" == *.js ]]; then file_type=\"javascript\";\n    elif [[ \"$file_abs_path\" == *.sh ]]; then file_type=\"shell_script_non_exec\";\n    elif [[ \"$file_abs_path\" =~ \\.(txt|log|md|csv|json|xml|html|yaml|yml|rst)$ ]]; then file_type=\"text_data_doc\";\n    elif [[ \"$file_abs_path\" =~ \\.(docx|pdf|odt)$ ]]; then file_type=\"binary_doc\";\n    else\n        file_type=\"other_binary_or_unknown\"\n    fi\n\n    # Check for references using git grep if in a git repo\n    if command -v git >/dev/null 2>&1 && git -C \"$PROJECT_ROOT_ABS\" rev-parse --is-inside-work-tree >/dev/null 2>&1; then\n        references_count=$(git grep -lw \"$(basename \"$file_abs_path\")\" -- \"$PROJECT_ROOT_ABS\" 2>/dev/null | wc -l)\n    else\n        references_count=0 # Not a git repo or git command failed, or simply no references\n    fi\n    \n    # Extract metadata if present (example: \"Expires: YYYY-MM-DD\")\n    if [[ -f \"$file_abs_path\" ]] && [[ -r \"$file_abs_path\" ]]; then\n        if head -n 5 \"$file_abs_path\" 2>/dev/null | grep -q -i \"expires:\"; then\n            expiration_info=$(head -n 5 \"$file_abs_path\" 2>/dev/null | grep -i \"expires:\" | head -1 | sed 's/.*[Ee]xpires: //')\n        fi\n    fi\n\n    # Check Git tracking status\n    if command -v git >/dev/null 2>&1 && git -C \"$PROJECT_ROOT_ABS\" rev-parse --is-inside-work-tree >/dev/null 2>&1; then\n      if git -C \"$PROJECT_ROOT_ABS\" ls-files --error-unmatch \"$file_abs_path\" >/dev/null 2>&1; then\n          git_tracked_status=\"true\"\n      fi\n    fi\n    \n    # File modification timestamp (Unix epoch)\n    local modified_timestamp=\"0\"\n    if [[ -e \"$file_abs_path\" ]]; then # Check if file exists before stat\n        if [[ \"$(uname)\" == \"Darwin\" ]]; then\n            modified_timestamp=$(stat -f%m \"$file_abs_path\" 2>/dev/null || echo 0)\n        else\n            modified_timestamp=$(stat -c%Y \"$file_abs_path\" 2>/dev/null || echo 0)\n        fi\n    fi\n\n    # File size\n    local file_size=\"0\"\n    if [[ -e \"$file_abs_path\" ]]; then # Check if file exists before stat\n        if [[ \"$(uname)\" == \"Darwin\" ]]; then\n            file_size=$(stat -f%z \"$file_abs_path\" 2>/dev/null || echo 0)\n        else\n            file_size=$(stat -c%s \"$file_abs_path\" 2>/dev/null || echo 0)\n        fi\n    fi\n\n    # Heuristic for purpose based on name/path\n    if [[ \"$file_rel_path\" =~ (tmp/|temp/|\\.tmp$|\\.bak$|_backup[0-9-]*) ]]; then\n        purpose_heuristic=\"temporary_or_backup\"\n    elif [[ \"$file_rel_path\" =~ (log/|logs/|\\.log$) ]]; then\n        purpose_heuristic=\"log_file\"\n    elif [[ \"$file_rel_path\" =~ (draft|report|output|ai_generated_|_to_be_deleted_) ]]; then\n        purpose_heuristic=\"generated_output_or_draft\"\n    elif [[ \"$file_rel_path\" =~ (scripts/|tools/) && ( \"$file_type\" == \"python_script\" || \"$file_type\" == \"shell_script\" ) ]]; then\n         purpose_heuristic=\"utility_script\"\n    fi\n\n    # Create JSON object per file\n    jq -n --arg path \"$file_abs_path\" \\\n          --arg type \"$file_type\" \\\n          --argjson size \"$file_size\" \\\n          --arg modified_epoch \"$modified_timestamp\" \\\n          --argjson references \"$references_count\" \\\n          --arg expiration \"$expiration_info\" \\\n          --argjson git_tracked \"$git_tracked_status\" \\\n          --arg owner \"$owner_info\" \\\n          --arg purpose \"$purpose_heuristic\" \\\n          '{path: $path, type: $type, size: $size, modified_epoch: $modified_epoch, references: $references, expiration: $expiration, git_tracked: $git_tracked, owner: $owner, purpose_heuristic: $purpose}'\n}\n\nexport -f analyze_file # Export function for find -exec\nexport PROJECT_ROOT_ABS # Export for analyze_file\n\n# Check if jq is installed\nif ! command -v jq >/dev/null 2>&1; then\n    echo \"‚ùå Error: jq is required but not installed. Please install jq first.\"\n    echo \"   Ubuntu/Debian: sudo apt-get install jq\"\n    echo \"   macOS: brew install jq\"\n    exit 1\nfi\n\n# Define exclusion patterns for find\n# IMPORTANT: Customize these exclusions for your project\nEXCLUDE_PATTERNS=(\n    -path \"*/.git/*\" \\\n    -o -path \"*/.venv/*\" \\\n    -o -path \"*/venv/*\" \\\n    -o -path \"*/node_modules/*\" \\\n    -o -path \"*/bower_components/*\" \\\n    -o -path \"*/dist/*\" \\\n    -o -path \"*/build/*\" \\\n    -o -path \"*/target/*\" \\\n    -o -path \"*/__pycache__/*\" \\\n    -o -path \"*/.pytest_cache/*\" \\\n    -o -path \"*/.mypy_cache/*\" \\\n    -o -path \"*/.hypothesis/*\" \\\n    -o -path \"*/docs/official_releases/*\" \\\n    -o -path \"*/data/production_seeds/*\" \\\n    -o -path \"*/requirements/frozen/*\" \\\n    -o -path \"*/.ruff_cache/*\" \\\n    -o -path \"*/admin-ui/node_modules/*\" \\\n    -o -path \"*/admin-ui/dist/*\" \\\n    -o -path \"*/admin-ui/.next/*\" \\\n    -o -path \"*/dashboard/node_modules/*\" \\\n    -o -path \"*/dashboard/.next/*\" \\\n    # Add more project-specific exclusions here\n)\n\n# Scan for all files initially, then filter in jq or Python for more complex logic\n# This find command lists all files and pipes to jq for aggregation.\n# analyze_file is called for each file.\necho \"üìÇ Scanning files...\"\nfind \"$PROJECT_ROOT_ABS\" \\( \"${EXCLUDE_PATTERNS[@]}\" \\) -prune -o -type f -print0 | \\\n    while IFS= read -r -d '' file; do\n        # Get relative path from PROJECT_ROOT_ABS\n        rel_path=\"${file#$PROJECT_ROOT_ABS/}\"\n        # Ensure file still exists before analyzing (could be deleted by another process)\n        if [ -f \"$file\" ]; then\n            analyze_file \"$rel_path\" \"$PROJECT_ROOT_ABS\"\n        fi\n    done | \\\n    jq -s '.' > \"$PROJECT_ROOT_ABS/$INVENTORY_FILE\"\n\nINVENTORY_COUNT=$(jq 'length' \"$PROJECT_ROOT_ABS/$INVENTORY_FILE\" 2>/dev/null || echo 0)\necho \"üìä Inventory complete. Scanned $INVENTORY_COUNT files. Report: $PROJECT_ROOT_ABS/$INVENTORY_FILE\"\necho \"‚ÑπÔ∏è  Note: 'references' count is based on git grep. 'owner' info is not currently collected.\"\necho \"Next step: Run 'python scripts/cleanup_engine.py $PROJECT_ROOT_ABS/$INVENTORY_FILE'\" 