#!/bin/bash
# setup_codespace.sh - Set up GitHub Codespaces environment for MCP Server
#
# This script configures the GitHub Codespaces environment with pre-authenticated
# GCP access using the provided credentials. It sets up the necessary environment
# variables, installs dependencies, and configures the development environment.

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Display banner
echo -e "${BLUE}"
echo "╔═══════════════════════════════════════════════════════════════╗"
echo "║              MCP Server Codespace Setup Script                ║"
echo "╚═══════════════════════════════════════════════════════════════╝"
echo -e "${NC}"

# Function to display step information
step() {
  echo -e "${GREEN}➤ $1${NC}"
}

# Function to display information
info() {
  echo -e "${BLUE}ℹ $1${NC}"
}

# Function to display warnings
warn() {
  echo -e "${YELLOW}⚠ $1${NC}"
}

# Function to display errors and exit
error() {
  echo -e "${RED}✖ $1${NC}"
  exit 1
}

# Check if running in Codespaces
if [ -z "${CODESPACES}" ]; then
  warn "This script is designed to run in GitHub Codespaces."
  read -p "Continue anyway? (y/n) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    exit 1
  fi
fi

# Check for required environment variables
step "Checking for required environment variables"

if [ -z "${GCP_MASTER_SERVICE_JSON}" ]; then
  warn "GCP_MASTER_SERVICE_JSON environment variable is not set."
  warn "GCP authentication will not be configured."
  HAS_GCP_CREDENTIALS=false
else
  info "GCP_MASTER_SERVICE_JSON environment variable is set."
  HAS_GCP_CREDENTIALS=true
fi

if [ -z "${GH_CLASSIC_PAT_TOKEN}" ]; then
  warn "GH_CLASSIC_PAT_TOKEN environment variable is not set."
  warn "GitHub authentication will not be configured."
  HAS_GH_CREDENTIALS=false
else
  info "GH_CLASSIC_PAT_TOKEN environment variable is set."
  HAS_GH_CREDENTIALS=true
fi

if [ -z "${GH_FINE_GRAINED_PAT_TOKEN}" ]; then
  warn "GH_FINE_GRAINED_PAT_TOKEN environment variable is not set."
  warn "GitHub deployments will not be configured."
  HAS_GH_FINE_GRAINED=false
else
  info "GH_FINE_GRAINED_PAT_TOKEN environment variable is set."
  HAS_GH_FINE_GRAINED=true
fi

# Create .env.development file if it doesn't exist
step "Setting up environment variables"
ENV_FILE="$(pwd)/.env.development"

if [ -f "$ENV_FILE" ]; then
  info "Environment file already exists: $ENV_FILE"
else
  info "Creating environment file: $ENV_FILE"
  cat > "$ENV_FILE" << EOF
# MCP Server Development Environment Variables
# Generated by setup_codespace.sh

# GCP Configuration
GCP_PROJECT_ID=cherry-ai-project
GCP_REGION=us-central1

# Redis Configuration
REDIS_HOST=localhost
REDIS_PORT=6379

# Development Settings
DEBUG=true
LOG_LEVEL=DEBUG
EOF
  info "Created environment file with default values."
fi

# Set up GCP authentication if credentials are available
if [ "$HAS_GCP_CREDENTIALS" = true ]; then
  step "Setting up GCP authentication"
  
  # Create a temporary file for the service account key
  echo "$GCP_MASTER_SERVICE_JSON" > /tmp/gcp-key.json
  
  # Authenticate with GCP
  gcloud auth activate-service-account --key-file=/tmp/gcp-key.json || error "Failed to authenticate with GCP"
  
  # Extract project ID from service account key
  PROJECT_ID=$(jq -r '.project_id' /tmp/gcp-key.json)
  
  # Configure gcloud CLI
  gcloud config set project "$PROJECT_ID" || warn "Failed to set GCP project"
  
  # Configure Docker for GCR
  gcloud auth configure-docker --quiet || warn "Failed to configure Docker for GCR"
  
  # Update environment file with project ID
  sed -i "s/GCP_PROJECT_ID=.*/GCP_PROJECT_ID=$PROJECT_ID/" "$ENV_FILE"
  
  # Clean up temporary file
  rm -f /tmp/gcp-key.json
  
  info "GCP authentication configured successfully."
else
  warn "Skipping GCP authentication setup."
fi

# Set up GitHub authentication if credentials are available
if [ "$HAS_GH_CREDENTIALS" = true ]; then
  step "Setting up GitHub authentication"
  
  # Configure GitHub CLI
  echo "$GH_CLASSIC_PAT_TOKEN" | gh auth login --with-token || warn "Failed to authenticate with GitHub"
  
  info "GitHub authentication configured successfully."
else
  warn "Skipping GitHub authentication setup."
fi

# Install dependencies
step "Installing dependencies"

# Check if Poetry is installed
if ! command -v poetry &> /dev/null; then
  info "Installing Poetry"
  curl -sSL https://install.python-poetry.org | python3 -
  export PATH="$HOME/.local/bin:$PATH"
fi

# Install project dependencies
cd "$(dirname "$0")/.." || error "Failed to change directory"
poetry install || error "Failed to install dependencies"

# Set up Redis for local development
step "Setting up Redis for local development"

# Check if Docker is available
if command -v docker &> /dev/null; then
  # Check if Redis is already running
  if docker ps | grep -q redis-stack; then
    info "Redis is already running."
  else
    info "Starting Redis container"
    docker run -d --name redis-stack -p 6379:6379 -p 8001:8001 redis/redis-stack:latest || warn "Failed to start Redis container"
  fi
else
  warn "Docker is not available. Skipping Redis setup."
fi

# Set up pre-commit hooks
step "Setting up pre-commit hooks"

# Check if pre-commit is installed
if ! command -v pre-commit &> /dev/null; then
  info "Installing pre-commit"
  pip install pre-commit
fi

# Install pre-commit hooks
if [ -f .pre-commit-config.yaml ]; then
  pre-commit install || warn "Failed to install pre-commit hooks"
else
  info "Creating pre-commit configuration"
  cat > .pre-commit-config.yaml << EOF
repos:
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
    -   id: trailing-whitespace
    -   id: end-of-file-fixer
    -   id: check-yaml
    -   id: check-added-large-files

-   repo: https://github.com/psf/black
    rev: 23.7.0
    hooks:
    -   id: black

-   repo: https://github.com/pycqa/isort
    rev: 5.12.0
    hooks:
    -   id: isort

-   repo: https://github.com/pycqa/flake8
    rev: 6.1.0
    hooks:
    -   id: flake8
EOF
  pre-commit install || warn "Failed to install pre-commit hooks"
fi

# Create a sample Redis connection test script
step "Creating Redis connection test script"

TEST_SCRIPT="$(pwd)/scripts/test_redis_connection.py"
if [ -f "$TEST_SCRIPT" ]; then
  info "Redis test script already exists: $TEST_SCRIPT"
else
  info "Creating Redis test script: $TEST_SCRIPT"
  mkdir -p "$(dirname "$TEST_SCRIPT")"
  cat > "$TEST_SCRIPT" << EOF
#!/usr/bin/env python3
"""
Test Redis connection for MCP Server.

This script tests the connection to Redis and performs basic operations
to verify that Redis is working correctly.
"""

import asyncio
import os
import sys
from typing import Dict, Any

try:
    import redis.asyncio as redis
    HAS_REDIS = True
except ImportError:
    HAS_REDIS = False

async def test_redis_connection() -> Dict[str, Any]:
    """Test Redis connection and perform basic operations."""
    if not HAS_REDIS:
        return {"status": "error", "message": "Redis package not installed"}
    
    # Get Redis connection details from environment variables
    host = os.environ.get("REDIS_HOST", "localhost")
    port = int(os.environ.get("REDIS_PORT", "6379"))
    
    try:
        # Connect to Redis
        r = redis.Redis(
            host=host,
            port=port,
            decode_responses=True,
            socket_timeout=5.0,
            socket_connect_timeout=5.0,
            retry_on_timeout=True
        )
        
        # Test connection
        await r.ping()
        
        # Test basic operations
        await r.set("mcp:test:key", "Hello, MCP!")
        value = await r.get("mcp:test:key")
        
        # Clean up
        await r.delete("mcp:test:key")
        
        return {
            "status": "success",
            "message": f"Successfully connected to Redis at {host}:{port}",
            "value": value
        }
    except Exception as e:
        return {"status": "error", "message": str(e)}

async def main() -> None:
    """Run the Redis connection test."""
    print("Testing Redis connection...")
    result = await test_redis_connection()
    
    if result["status"] == "success":
        print(f"✅ {result['message']}")
        print(f"✅ Test value: {result['value']}")
        sys.exit(0)
    else:
        print(f"❌ Error: {result['message']}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())
EOF
  chmod +x "$TEST_SCRIPT"
  info "Created Redis test script."
fi

# Display completion message
echo -e "${GREEN}╔═══════════════════════════════════════════════════════════════╗${NC}"
echo -e "${GREEN}║                 Codespace Setup Complete!                     ║${NC}"
echo -e "${GREEN}╚═══════════════════════════════════════════════════════════════╝${NC}"
echo -e "${BLUE}Project directory: ${NC}$(pwd)"
echo -e "${BLUE}Environment file: ${NC}$ENV_FILE"
echo -e "${BLUE}Redis test script: ${NC}$TEST_SCRIPT"
echo ""
echo -e "${YELLOW}Next steps:${NC}"
echo -e "1. Run ${BLUE}poetry shell${NC} to activate the virtual environment"
echo -e "2. Run ${BLUE}python scripts/test_redis_connection.py${NC} to test Redis connection"
echo -e "3. Run ${BLUE}python -m mcp_server.main${NC} to start the MCP server"
echo ""
echo -e "Happy coding! 🚀"