from fastapi import APIRouter, Depends, HTTPException, status, Body
from uuid import UUID, uuid4
from typing import List, Optional, Any, Dict # Added Any, Dict
from datetime import datetime
from pydantic import BaseModel, Field # Ensure BaseModel and Field are imported

from core.models.mcp_instance_models import UserDefinedMCPServerInstanceConfig, MCPServerInstanceStatus, MCPServerResourceConfig, AIProvider, ContextSourceConfig # Ensure all necessary models are imported
from core.services.mcp_config_manager import MCPConfigManager

router = APIRouter(
    prefix="/api/v1/mcp",
    tags=["MCP Server Management"]
)

# Initialize the configuration manager
# The path should be relative to the project root or an absolute path.
# If running from `agent/app`, `../../config/mcp_servers.yaml` might be needed,
# or configure via environment variable. For now, assuming it's accessible.
config_manager = MCPConfigManager(config_filepath="config/mcp_servers.yaml")


# Pydantic model for request body for creating a new server instance
# Mirrors UserDefinedMCPServerInstanceConfig but omits fields auto-generated by the server
class MCPServerCreateRequest(BaseModel):
    name: str = Field(..., min_length=3, max_length=100, description="User-friendly name for the MCP server instance")
    description: Optional[str] = Field(default=None, max_length=500)
    target_ai_coders: List[Literal["RooCoder", "CursorAI", "Claude", "OpenAI_GPT4", "OpenAI_GPT3_5", "Gemini", "Copilot", "Generic"]] = Field( # type: ignore
        ...,
        description="Primary AI Coder(s) this server instance is intended to support or emulate."
    )
    enabled_internal_tools: List[Literal["copilot", "gemini"]] = Field( # type: ignore
        default_factory=list,
        description="Internal MCP tools to enable (maps to sections in the internal MCPConfig like 'copilot', 'gemini')"
    )
    copilot_config_override: Optional[Dict[str, Any]] = Field(default=None, description="Specific overrides for the 'copilot' section of the internal MCPConfig")
    gemini_config_override: Optional[Dict[str, Any]] = Field(default=None, description="Specific overrides for the 'gemini' section of the internal MCPConfig")
    base_docker_image: str = Field(default="mcp_server:latest", description="Base Docker image for this MCP instance")
    resources: MCPServerResourceConfig = Field(default_factory=MCPServerResourceConfig)
    custom_environment_variables: Dict[str, str] = Field(default_factory=dict)
    ai_providers: List[AIProvider] = Field(default_factory=list)
    context_sources: List[ContextSourceConfig] = Field(default_factory=list)
    desired_status: Literal["running", "stopped"] = Field(default="running") # type: ignore

    class Config:
        use_enum_values = True


# Pydantic model for request body for updating an existing server instance
# All fields are optional for partial updates
class MCPServerUpdateRequest(BaseModel):
    name: Optional[str] = Field(default=None, min_length=3, max_length=100)
    description: Optional[str] = Field(default=None, max_length=500)
    target_ai_coders: Optional[List[Literal["RooCoder", "CursorAI", "Claude", "OpenAI_GPT4", "OpenAI_GPT3_5", "Gemini", "Copilot", "Generic"]]] = None # type: ignore
    enabled_internal_tools: Optional[List[Literal["copilot", "gemini"]]] = None # type: ignore
    copilot_config_override: Optional[Dict[str, Any]] = None
    gemini_config_override: Optional[Dict[str, Any]] = None
    base_docker_image: Optional[str] = None
    resources: Optional[MCPServerResourceConfig] = None
    custom_environment_variables: Optional[Dict[str, str]] = None
    ai_providers: Optional[List[AIProvider]] = None
    context_sources: Optional[List[ContextSourceConfig]] = None
    desired_status: Optional[Literal["running", "stopped"]] = None # type: ignore
    # generated_mcp_internal_config_yaml is not updatable by user directly
    # id, created_at, updated_at are managed by the system

    class Config:
        use_enum_values = True


@router.post("/servers", response_model=UserDefinedMCPServerInstanceConfig, status_code=status.HTTP_201_CREATED)
async def create_mcp_server(
    server_data: MCPServerCreateRequest = Body(...)
):
    """
    Create a new MCP Server instance configuration.
    """
    # Create a full UserDefinedMCPServerInstanceConfig from the request model
    new_config_pydantic = UserDefinedMCPServerInstanceConfig(
        **server_data.model_dump(), # Pydantic v2
        # id, created_at, updated_at will be set by the manager or have defaults
    )
    # The save_config method will handle ID generation and timestamps if not present (which they aren't for create)
    saved_config = await config_manager.save_config(new_config_pydantic)
    return saved_config

@router.get("/servers", response_model=List[UserDefinedMCPServerInstanceConfig])
async def get_all_mcp_servers():
    """
    Retrieve all MCP Server instance configurations.
    """
    return await config_manager.get_all_configs()

@router.get("/servers/{server_id}", response_model=UserDefinedMCPServerInstanceConfig)
async def get_mcp_server(server_id: UUID):
    """
    Retrieve a specific MCP Server instance configuration by ID.
    """
    config = await config_manager.get_config_by_id(server_id)
    if not config:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="MCP Server configuration not found")
    return config

@router.put("/servers/{server_id}", response_model=UserDefinedMCPServerInstanceConfig)
async def update_mcp_server(
    server_id: UUID,
    update_data: MCPServerUpdateRequest = Body(...)
):
    """
    Update an existing MCP Server instance configuration.
    """
    existing_config = await config_manager.get_config_by_id(server_id)
    if not existing_config:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="MCP Server configuration not found")

    # For Pydantic v2: .model_dump(exclude_unset=True)
    # For Pydantic v1: .dict(exclude_unset=True)
    update_data_dict = update_data.model_dump(exclude_unset=True)

    # Create updated model
    # For Pydantic v2: updated_config = existing_config.model_copy(update=update_data_dict)
    # For Pydantic v1: updated_config = existing_config.copy(update=update_data_dict)
    updated_config = existing_config.model_copy(update=update_data_dict)

    saved_config = await config_manager.save_config(updated_config)
    return saved_config

@router.delete("/servers/{server_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_mcp_server(server_id: UUID):
    """
    Delete an MCP Server instance configuration.
    """
    deleted = await config_manager.delete_config(server_id)
    if not deleted:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="MCP Server configuration not found")
    return None # For 204 No Content response

@router.get("/servers/{server_id}/status", response_model=MCPServerInstanceStatus)
async def get_mcp_server_status(server_id: UUID):
    """
    Get the current status of a specific MCP Server instance.
    (This is a placeholder and does not reflect actual server status yet)
    """
    # First, check if the config exists to ensure the server_id is valid
    config = await config_manager.get_config_by_id(server_id)
    if not config:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="MCP Server configuration not found, cannot get status.")

    # Placeholder status
    return MCPServerInstanceStatus(
        instance_id=server_id,
        actual_status="UNKNOWN", # Default
        message="Status polling and actual instance management not yet implemented."
    )

# Note: Literal type hints might need `from typing import Literal` if not already globally available
# Pydantic v1/v2 differences for model_dump/dict and model_copy/copy are important. Code assumes v2 style.
# Added type: ignore for Literal fields in request models where mypy might complain if Literal isn't recognized in that context by the linter.
# This is common in FastAPI/Pydantic when List[Literal[...]] is used.
